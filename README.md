# What are RIBs For?

### RIBs는 무엇을 위한 것인가?
RIBs는 Uber의 크로스 플랫폼 아키텍처 프레임워크이다.<br>
이 프레임 워크는 많은 nested states를 포함하는 대규모 모바일 어플레이케이션을 위해 설계되었다.
<br>
<br>

```
👩🏻‍🔧 Uber : 우리는 이 프레임워크를 설계할 때, 다음과 같은 원칙을 준수했소.
```

#### 1. Encourage Cross-Platform Collaboration
> iOS/Android 플랫폼간 협업 장려!
> - RIBs는 Android와 iOS에 대해 유사한 개발 패턴을 제공한다. 따라서 RIBs를 사용하게 되면 iOS및 Android 플랫폼의 엔지니어는 기능에 대해 공동으로 설계된 단일 아키텍처를 공유할 수 있다.


#### 2. Minimize Global States and Decisions
> 전역 상태 이슈 최소화!
> - 전역 상태의 변경으로 예측할 수 없는 동작이 발생하고 엔지니어가 변경 사항의 전체적인 영향을 파악하는 것이 불가능할 수 있다. RIB은 깊은 계층 구조 내에서 상태를 캡슐화하기 때문에 전역 상태에 대한 이슈를 최소화한다.


#### 3. Testability and Isolation
> 각 클래스의 단일 책임으로 유닛 테스트를 쉽게!
> - 클래스는 유닛 테스트가 쉬워야 하며 추론가능해야한다. 개별적인 RIB 클래스들은 각각의 책임을 가지고 있다. (라우팅, 비즈니스 로직, 뷰 로직, 기타 RIB 생성) 그 외에도 상위 RIB 로직은 대부분 하위 RIB 로직에서 분리된다. 따라서 RIB 클래스를 쉽게 테스트하고 독립적으로 추론할 수 있다.


#### 4. Tooling for Developer Productivity
> 개발자 생산성을 위한 도구!
> - 중요하지 않은 아키텍쳐 패턴을 채택하는 것은 강력한 도구 없이는 소규모 어플레케이션 이상으로 확장할 수 없다. RIB는 코드 생성, 정적 분석, 런타임 통합과 관련된 IDE도구와 함께 제공되며, 이 모두는 크고 작은 개발자 생산성을 향상시킨다.


#### 5. Open-Closed Principle
> 개방형 원칙
> - 개발자는 가능한 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다. RIB를 사용할 때 몇몇 곳에서 볼 수 있는데, 예를 들면, 상위 RIB를 거의 변경하지 않고 상위로부터 종속성을 필요로 하는 복잡한 하위 RIB를 연결하거나 빌드할 수 있다.


#### 6. Structured around Business Logic
> 비즈니스 로직을 중심으로 구조화
> - 앱의 비즈니스 로직 구조는 UI의 구조를 엄격하게 따라할 필요가 없다. 예를 들면, 애니메이션과 뷰 퍼포먼스를 용이하게 하기 위해 뷰 계층 구조는 RIB 계층 구조보다 얕을 수 있다. 또는, 단일 기능 RIB가 UI의 다른 위치에 다하는 세가지 뷰를 제어할 수도 있다.


#### 7. Explicit Contracts
> 명시적 계약
> - 요구 사항은 컴파일 시간에 안전한 계약으로 선언되어야 한다. 클래스 종속성과 순서 종속성이 충족되지 않으면 클래스가 컴파일 되지 않아야 한다. Reactive를 사용하여 순서 종속성을 나타내고, type safe depencency injection (종속성 주입, DI) 시스템을 사용하여 클래스의 종속성을 나타내고, 많은 DI 범위를 사용하여 데이터 불변성 생성을 권장한다.

<br>
<br>
<br>

# Parts of a RIB

### RIB를 구성하는 클래스들을 살펴보자.
이전에 VIPER 아키텍처로 작업한 적이 있따면 RIB의 클래스 분석이 익숙할 것이다. <br>
RIB은 일반적으로 다음 요소로 구성되며, 모든 요소는 자체 클래스에서 구현된다.

![parts of a ribs](https://user-images.githubusercontent.com/58356885/150979630-4c895df9-2423-469d-8ba6-8fd53ae3d996.png)


#### 1. Interator
> 인터랙터
> - Interator에는 비즈니스 로직이 포함되어 있다. 여기에서 Rx 구독을 수행하고, 상태 변경 결정을 내리고, 데이터 저장할 위치를 정하고, 자식으로 연결되어야 하는 RIBs를 결정한다.
> - Interactor가 수행하는 모든 작업은 해당 수명 주기로 제한되어야 한다. 우리는 Interator가 활성화된 경우네만 비즈니스 로직이 실행되도록 tooling을 구축해두었다. 이렇게 하면 Interactor가 비활성화되지만 구독이 계속 실행되고 비즈니스 논리 또는 UI 상태에 대한 원치않는 업데이트가 발생하는 시나리오를 방지할 수 있다.

#### 2. Router
> 라우터
> - Router는 Interactor를 듣고(listen), 그것의 output을 child RIB에 attach / detach로 변환한다.
> - 라우터는 세가지 이유 때문에 존재한다.
> (1) 라우터는 자식 Interactor를 mocking하거나 다른 방식으로 존재 여부를 신경 쓸 필요 없이, 복잡한 Interactor 로직을 더 쉽게 테스트할 수 있도록 하는 Humble Objects 역할을 한다.
> (2) 라우터는 부모 Interactor와 자식 Interactor 사이에 부가적인 abstraction layer를 만든다. 이것은 인터랙터 사이의 동시적 커뮤니케이션을 쵸큼 어렵게 하고, RIBs 간의 다이렉트 연결 대신 반응형 커뮤니케이션을 채택하도록 권장한다.
> (3) Router에는 Interactor에 의해 구현되는 단순하고 반복적인 라우팅 로직이 포함되어 있다. 이 보일러 플레이트 코드를 제외하면 Interactor를 작게 유지하고 RIB에 제공되는 핵심 비즈니스 로직에 더 집중할 수 있습니다.

#### 3. Builder
> 빌더
> - 빌더의 책임은 모든 RIB의 구성 클래스들과 RIB의 자식에 대한 빌더를 인스턴스화하는 것이다.
> - 빌더에서 클래스 생성 빌더를 분리하면 iOS에서 mocking 가능성에 대한 지원이 추가되고, 나머지 RIB 코드는 DI 구현의 세부사항에 대해 무관해진다. 빌더는 프로젝트에 사용된 DI 시스템을 인식해야하는 RIB의 유일한 부분이다. 다른 빌더를 구현하면 다른 DI 매커니즘을 사용하여 프로젝트에서 나머지 RIB 코드를 재사용할 수 있다.

#### 4. Presenter
> 프레젠터
> - 프레젠터는 비즈니스모델을 뷰모델로 또는 그 반대로 변환하는 상태독립적인 클래스이다.
> - 뷰 모델 전환 테스트를 용이하게 한다.
> - 하지만 종종, 변환 자체가 간단해서 전용 Presenter 클래스를 만들 필요까지는 없다.
> - Presenter가 생략되면, View Model을 번역하는 것은 View(Controller)나 Interactor가 책임을 진다.

#### 5. View(Controller)
> 뷰(컨트롤러)
> - 뷰는 UI를 빌드하고 업데이트 한다. 여기에는 UI 컴포넌트를 인스턴스화하고, 유저 인터랙션을 처리하고, UI 컴포넌트에 데이터 채우기 및 애니메이션이 포함된다.
> - 뷰는 가능한 DUMB(멍청한) 것으로 설계되었다. 뷰는 단시 정보를 표시하는 역할!이기 때문에 보통 유닛 테스트에 필요한 코드가 포함되어 있지 않다.

#### 6. Component
> 컴포넌트
> - 컴포넌트는 RIB 의존성을 관리하기 위해 사용된다.
> - 이들은 Builder가 RIB를 구성하는 다른 유닛들을 인스턴스화하도록 지원한다.
> - The Component는 RIB를 구축하는 데 필요한 외부 의존성에 대한 엑세스를 제공할 뿐만 아니라, RIB 자체에 의해 생산된 의존성을 소유하고 다른 RIB에서 이에 대한 엑세스를 제어한다.
> - 부모 RIB의 컴포넌트는 보통 부모 RIB의 의존성에 자식 RIB가 접근할 수 있게 자식 RIB 빌더에 주입된다.

<br>
<br>
<br>

# State Management

### RIB의 상태관리!
어플리케이션 상태는 RIB 트리에 현재 연결된 RIBs에 의해 크게 관리되고 표시된다.<br>
예를 들면, 유저가 간소화된 차량 공유 앱에서 다양한 상태를 진행하면, 앱은 다음 RIBs를 연결 및 분리를 하게 된다.(아래 GIF 참고)

![RIBs state](https://user-images.githubusercontent.com/58356885/150980237-1d8f9311-c872-4f41-9254-60120635d726.gif)

**RIB는 범위 안에서만 상태를 결정한다.** <br>
예를 들면, LoggedIn RIB는 오직 Request와 OnTrip과 같은 상태 간 전환에 대한 상태만 결정한다.<br>
LoggedIn RIB가 OnTrip 화면이 어떻게 작동해야할지에 대해서는 결정하지 않는다!<br>

**RIB를 삭제하거나 추가해서 모든 상태를 저장할 수 있는 것은 아니다.** <br>
예를 들면, 유저 프로필 세팅이 바뀐다고 RIB가 연결되거나 분리되지 않는다. 일반적으로, 세부정보가 변경될 때 값을 다시 방출하는 (re-emit) 불변 모델 스트림 (the streams of immutable models) 안에서 이 상태를 저장한다. 예를 들면, 유저의 이름은 LoggedIn 범위 내에 있는 ProfileDataStream 안에 저장될 수도 있다. 네트워크 응답만 이 스트림에 대한 write 액세스 권한을 가지고 있다. 이 스크림에 대한 read 권한을 제공하는 인터페이스를 DI 그래프 아래로 전달한다.

RIB 상태에 대해 a single source of truth(단일 진심 공급원, SSOT)를 강제하는 것은 RIBs 뿐이다. 이것은 React와 같이 독단적인 프레임워크가 이미 기본적으로 제공되는 것과는 대조된다. 각각의 RIB 컨텍스트 내에서 단뱡향 데이터 흐름을 촉진하는 패턴을 채택하도록 선택하거나, 효율적인 플랫폼 애니메이션 프레임워크를 활용하기 위해, 비즈니스 상태와 뷰 상태가 일시적으로 분기되도록 할 수 있다.

<br>
<br>
<br>

# Communication Between RIBs

### RIB간 통신
Interator가 비즈니스 로직을 결정할 때, 완료와 같은 이벤트를 다른 RIB에 알리고 데이터를 보내야할 수도 있다.<br>
RIB 프레임워크는 RIB 사이에 데이터를 전달하는 단일 방법이 포함되어 있지 않다.<br>
그럼에도 불구하고, 몇 가지 일반적인 패턴을 용이하게 하기 위해 만들어졌다.<br>

![stream](https://user-images.githubusercontent.com/58356885/150980458-f9eaf354-0e71-43e4-807f-3cc621756d67.png)

일반적으로, 통신이 자식 RIB로 내려가면, 이 정보를 RX Stream으로 방출하여 전달한다.<br>
또는 자식 RIB의 build() 메서드에 대한 파라미터로 포함될 수 있으며, 이 경우에 이 파라미터는 자식 RIB의 LifeCycle이 살아있는 동안 불변이 된다.

<br>
<br>
<br>

<p align="center"><img width="450" alt="listener" src="https://user-images.githubusercontent.com/58356885/150980508-8585955d-8d69-4b81-acc5-fbdc2a20cae1.png"></p>

만약, 통신이 부모 RIB의 Interactor로 RIB tree의 위쪽으로 이동한다면!<br>
부모 RIB가 자식 RIB보다 오래 지속될 수 있으므로 통신은 listener 인터페이스를 통해 수행된다.<br>
부모 RIB 또는 DI 그래프의 일부 개체는 listener 인터페이스를 구현하고, 자식 RIB이 호출할 수 있도록 listener 인터페이스를 DI 그래프에 배치한다.<br>

부모가 자식의 Rx Stream을 직접 구독하도록 하는 대신 이 패턴을 사용하여 데이터를 위쪽으로 전달하면, 몇 가지 이점이 있다.<br>
1) 메모리 누수를 방지할 수 있고
2) 부모가 어떤 자식 RIB와 연결되어 있는지 모른 채 작성 & 테스트 & 유지관리를 할 수 있으며
3) 자식 RIB를 연결 / 분리하는 데 필요한 형식의 양을 줄일 수 있다.

이런 식으로 자식 RIB을 연결할 때 Rx Stream이나 listener를 취소/재등록할 필요가 없다.
